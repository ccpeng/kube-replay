// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"
)

type ContainerLastState struct {
	ExitCode   *int64     `json:"exitCode,omitempty"`
	StartedAt  *time.Time `json:"startedAt,omitempty"`
	FinishedAt *time.Time `json:"finishedAt,omitempty"`
	Reason     *string    `json:"reason,omitempty"`
}

type ContainerResource struct {
	CPU              *string `json:"cpu,omitempty"`
	Memory           *string `json:"memory,omitempty"`
	EphemeralStorage *string `json:"ephemeralStorage,omitempty"`
}

type ContainerResourceInput struct {
	CPU              *string `json:"cpu,omitempty"`
	Memory           *string `json:"memory,omitempty"`
	EphemeralStorage *string `json:"ephemeralStorage,omitempty"`
}

type ContainerResources struct {
	Requests *ContainerResource `json:"requests,omitempty"`
	Limits   *ContainerResource `json:"limits,omitempty"`
}

type ContainerResourcesInput struct {
	Requests *ContainerResourceInput `json:"requests,omitempty"`
	Limits   *ContainerResourceInput `json:"limits,omitempty"`
}

// Point‑in‑time view of a container inside a Pod.
type ContainerSnapshot struct {
	ContainerID  string              `json:"containerID"`
	Name         string              `json:"name"`
	Image        string              `json:"image"`
	ImageID      string              `json:"imageID"`
	Resources    *ContainerResources `json:"resources,omitempty"`
	Ready        bool                `json:"ready"`
	RestartCount *int64              `json:"restartCount,omitempty"`
	StartedAt    time.Time           `json:"startedAt"`
	Running      bool                `json:"running"`
	State        *ContainerState     `json:"state"`
	LastState    *ContainerLastState `json:"lastState,omitempty"`
}

type ContainerSnapshotInput struct {
	ContainerID  string                   `json:"containerID"`
	Name         string                   `json:"name"`
	Image        string                   `json:"image"`
	ImageID      string                   `json:"imageID"`
	Resources    *ContainerResourcesInput `json:"resources,omitempty"`
	Ready        bool                     `json:"ready"`
	RestartCount *int64                   `json:"restartCount,omitempty"`
	StartedAt    time.Time                `json:"startedAt"`
	Running      bool                     `json:"running"`
	State        *ContainerStateInput     `json:"state"`
	LastState    *ContainerStateInput     `json:"lastState,omitempty"`
}

type ContainerState struct {
	ExitCode   *int64     `json:"exitCode,omitempty"`
	StartedAt  time.Time  `json:"startedAt"`
	FinishedAt *time.Time `json:"finishedAt,omitempty"`
	Reason     *string    `json:"reason,omitempty"`
}

type ContainerStateInput struct {
	ExitCode   *int64     `json:"exitCode,omitempty"`
	StartedAt  time.Time  `json:"startedAt"`
	FinishedAt *time.Time `json:"finishedAt,omitempty"`
	Reason     *string    `json:"reason,omitempty"`
}

type Mutation struct {
}

// CPU and memory capacity/allocatable for a node.
type NodeCapacity struct {
	CPU              string `json:"cpu"`
	Memory           string `json:"memory"`
	EphemeralStorage string `json:"ephemeralStorage"`
	Pods             *int64 `json:"pods,omitempty"`
}

type NodeCapacityInput struct {
	CPU              string `json:"cpu"`
	Memory           string `json:"memory"`
	EphemeralStorage string `json:"ephemeralStorage"`
	Pods             *int64 `json:"pods,omitempty"`
}

type NodeInfo struct {
	Architecture            string  `json:"architecture"`
	ContainerRuntimeVersion string  `json:"containerRuntimeVersion"`
	KernelVersion           string  `json:"kernelVersion"`
	KubeletVersion          string  `json:"kubeletVersion"`
	KubeProxyVersion        string  `json:"kubeProxyVersion"`
	OsImage                 string  `json:"osImage"`
	OperatingSystem         *string `json:"operatingSystem,omitempty"`
	MachineID               string  `json:"machineId"`
	SystemUUID              string  `json:"systemUUID"`
	BootID                  string  `json:"bootID"`
}

type NodeInfoInput struct {
	Architecture            string  `json:"architecture"`
	ContainerRuntimeVersion string  `json:"containerRuntimeVersion"`
	KernelVersion           string  `json:"kernelVersion"`
	KubeletVersion          string  `json:"kubeletVersion"`
	KubeProxyVersion        string  `json:"kubeProxyVersion"`
	OsImage                 string  `json:"osImage"`
	OperatingSystem         *string `json:"operatingSystem,omitempty"`
	MachineID               string  `json:"machineId"`
	SystemUUID              string  `json:"systemUUID"`
	BootID                  string  `json:"bootID"`
}

// Point‑in‑time view of a single Node.
type NodeSnapshot struct {
	ID         string         `json:"id"`
	Timestamp  time.Time      `json:"timestamp"`
	Name       string         `json:"name"`
	Roles      []string       `json:"roles,omitempty"`
	ProviderID *string        `json:"providerID,omitempty"`
	Info       *NodeInfo      `json:"info"`
	State      *NodeState     `json:"state"`
	Pods       []*PodSnapshot `json:"pods"`
}

type NodeSnapshotInput struct {
	ID         string              `json:"id"`
	Timestamp  time.Time           `json:"timestamp"`
	Name       string              `json:"name"`
	Roles      []string            `json:"roles,omitempty"`
	ProviderID *string             `json:"providerID,omitempty"`
	Info       *NodeInfoInput      `json:"info"`
	State      *NodeStateInput     `json:"state"`
	Pods       []*PodSnapshotInput `json:"pods"`
}

// Condensed status block for a Node.
type NodeState struct {
	Status        NodeCondition `json:"status"`
	Capacity      *NodeCapacity `json:"capacity"`
	Allocatable   *NodeCapacity `json:"allocatable"`
	Taints        []*NodeTaint  `json:"taints"`
	Unschedulable *bool         `json:"unschedulable,omitempty"`
}

type NodeStateInput struct {
	Status        NodeCondition      `json:"status"`
	Timestamp     time.Time          `json:"timestamp"`
	Capacity      *NodeCapacityInput `json:"capacity"`
	Allocatable   *NodeCapacityInput `json:"allocatable"`
	Taints        []*NodeTaintInput  `json:"taints"`
	Unschedulable *bool              `json:"unschedulable,omitempty"`
}

type NodeTaint struct {
	Key       string     `json:"key"`
	Value     *string    `json:"value,omitempty"`
	Effect    string     `json:"effect"`
	TimeAdded *time.Time `json:"timeAdded,omitempty"`
}

type NodeTaintInput struct {
	Key       string     `json:"key"`
	Value     *string    `json:"value,omitempty"`
	Effect    string     `json:"effect"`
	TimeAdded *time.Time `json:"timeAdded,omitempty"`
}

// Point‑in‑time view of a single Pod.
type PodSnapshot struct {
	ID                  string               `json:"id"`
	NodeID              string               `json:"nodeID"`
	Timestamp           time.Time            `json:"timestamp"`
	Name                string               `json:"name"`
	Namespace           *string              `json:"namespace,omitempty"`
	Status              PodPhase             `json:"status"`
	InitContainers      []*ContainerSnapshot `json:"initContainers,omitempty"`
	Containers          []*ContainerSnapshot `json:"containers"`
	EphemeralContainers []*ContainerSnapshot `json:"ephemeralContainers,omitempty"`
	StartedAt           time.Time            `json:"startedAt"`
	DeletedAt           *time.Time           `json:"deletedAt,omitempty"`
	FinishedAt          *time.Time           `json:"finishedAt,omitempty"`
	DeletedBy           *string              `json:"deletedBy,omitempty"`
	QosClass            PodQOSClass          `json:"qosClass"`
}

type PodSnapshotInput struct {
	ID                  string                    `json:"id"`
	NodeID              string                    `json:"nodeID"`
	Timestamp           time.Time                 `json:"timestamp"`
	Name                string                    `json:"name"`
	Namespace           *string                   `json:"namespace,omitempty"`
	Status              PodPhase                  `json:"status"`
	InitContainers      []*ContainerSnapshotInput `json:"initContainers,omitempty"`
	Containers          []*ContainerSnapshotInput `json:"containers"`
	EphemeralContainers []*ContainerSnapshotInput `json:"ephemeralContainers,omitempty"`
	StartedAt           time.Time                 `json:"startedAt"`
	DeletedAt           *time.Time                `json:"deletedAt,omitempty"`
	FinishedAt          *time.Time                `json:"finishedAt,omitempty"`
	DeletedBy           *string                   `json:"deletedBy,omitempty"`
	QosClass            PodQOSClass               `json:"qosClass"`
}

type Query struct {
}

// Snapshot of an entire *cluster* at a specific instant.
// Returned by nodeStateRange / nodeStateAtTimestamp.
type TimedNodeSnapshots struct {
	Timestamp time.Time       `json:"timestamp"`
	Nodes     []*NodeSnapshot `json:"nodes"`
}

type NodeCondition string

const (
	NodeConditionReady    NodeCondition = "Ready"
	NodeConditionNotReady NodeCondition = "NotReady"
	NodeConditionUnknown  NodeCondition = "Unknown"
)

var AllNodeCondition = []NodeCondition{
	NodeConditionReady,
	NodeConditionNotReady,
	NodeConditionUnknown,
}

func (e NodeCondition) IsValid() bool {
	switch e {
	case NodeConditionReady, NodeConditionNotReady, NodeConditionUnknown:
		return true
	}
	return false
}

func (e NodeCondition) String() string {
	return string(e)
}

func (e *NodeCondition) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NodeCondition(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NodeCondition", str)
	}
	return nil
}

func (e NodeCondition) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *NodeCondition) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e NodeCondition) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type PodPhase string

const (
	PodPhasePending   PodPhase = "Pending"
	PodPhaseRunning   PodPhase = "Running"
	PodPhaseSucceeded PodPhase = "Succeeded"
	PodPhaseFailed    PodPhase = "Failed"
	PodPhaseUnknown   PodPhase = "Unknown"
)

var AllPodPhase = []PodPhase{
	PodPhasePending,
	PodPhaseRunning,
	PodPhaseSucceeded,
	PodPhaseFailed,
	PodPhaseUnknown,
}

func (e PodPhase) IsValid() bool {
	switch e {
	case PodPhasePending, PodPhaseRunning, PodPhaseSucceeded, PodPhaseFailed, PodPhaseUnknown:
		return true
	}
	return false
}

func (e PodPhase) String() string {
	return string(e)
}

func (e *PodPhase) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PodPhase(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PodPhase", str)
	}
	return nil
}

func (e PodPhase) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PodPhase) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PodPhase) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type PodQOSClass string

const (
	PodQOSClassBurstable  PodQOSClass = "Burstable"
	PodQOSClassGuaranteed PodQOSClass = "Guaranteed"
	PodQOSClassBestEffort PodQOSClass = "BestEffort"
	PodQOSClassUnknown    PodQOSClass = "Unknown"
)

var AllPodQOSClass = []PodQOSClass{
	PodQOSClassBurstable,
	PodQOSClassGuaranteed,
	PodQOSClassBestEffort,
	PodQOSClassUnknown,
}

func (e PodQOSClass) IsValid() bool {
	switch e {
	case PodQOSClassBurstable, PodQOSClassGuaranteed, PodQOSClassBestEffort, PodQOSClassUnknown:
		return true
	}
	return false
}

func (e PodQOSClass) String() string {
	return string(e)
}

func (e *PodQOSClass) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PodQOSClass(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PodQOSClass", str)
	}
	return nil
}

func (e PodQOSClass) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PodQOSClass) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PodQOSClass) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
